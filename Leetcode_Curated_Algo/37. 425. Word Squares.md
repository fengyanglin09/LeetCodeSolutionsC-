## 425. Word Squares
<pre>
Given a set of words (without duplicates), find all word squares you can build from them.

A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 â‰¤ k < max(numRows, numColumns).

For example, the word sequence ["ball","area","lead","lady"] forms a word square because each word reads the same both horizontally and vertically.

b a l l
a r e a
l e a d
l a d y
Note:
There are at least 1 and at most 1000 words.
All words will have the exact same length.
Word length is at least 1 and at most 5.
Each word contains only lowercase English alphabet a-z.
Example 1:

Input:
["area","lead","wall","lady","ball"]

Output:
[
  [ "wall",
    "area",
    "lead",
    "lady"
  ],
  [ "ball",
    "area",
    "lead",
    "lady"
  ]
]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).
Example 2:

Input:
["abat","baba","atan","atal"]

Output:
[
  [ "baba",
    "abat",
    "baba",
    "atan"
  ],
  [ "baba",
    "abat",
    "baba",
    "atal"
  ]
]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).
</pre>

-----------------------------------------------------------

## Solutions
### Solution1

```c++
//brute force

class Solution {
public:
    vector<vector<string>> wordSquares(vector<string>& words) {
        
        vector<string> each;
        vector<vector<string>> res;
        find(words, each, res);
        return res;
    }
    
private:
    ///////////
    void find(vector<string>& words, vector<string>& each, vector<vector<string>>& res){
        
        if(!each.empty() && (each.size() == each[0].size()) && isSq(each))
            res.push_back(each);    
        
        if(!each.empty() && each.size() > each[0].size()){
            return;
        }        
        
        int n = words.size();
        for(int i = 0; i < n; i++){
            each.push_back(words[i]);
            find(words, each, res);
            each.pop_back();
        }
    }
    ///////////
    bool isSq(vector<string> & w){
        int n = w.size();
        for(int i = 0; i < n; i++){
            int m = w[i].size();
            if(m > n) {return false;}
            for(int j = 0; j < m; j++){
                if(w[i][j] != w[j][i]){
                    return false;
                }
            }
        }
        return true;
    }
};

```
