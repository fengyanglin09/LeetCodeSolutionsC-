## 261. Graph Valid Tree
<pre>
Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), 
write a function to check whether these edges make up a valid tree.

Example 1:

Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]]
Output: true
Example 2:

Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]
Output: false
Note: you can assume that no duplicate edges will appear in edges. 
Since all edges are undirected, [0,1] is the same as [1,0] and thus will not appear together in edges.
</pre>
------------------------------------------------------------------
## Solutions
### Solution1
```c++
/*
a graph G is a tree iff:
1. G is fully connected-for every pair of nodes in G, there is a path between them.
2. G has no cycles-there is exactly one path between each pair of nodes in G

Solution 1, using dfs
*/
class Solution {
public:
    bool validTree(int n, vector<vector<int>>& edges) {
        //make a graph
        unordered_map<int,vector<int>> G;
        for(auto e : edges){
            int u = e[0];
            int v = e[1];
            G[u].push_back(v);
            G[v].push_back(u);
        }
        //dfs
        stack<int> s;
        unordered_set<int> visited;
        unordered_map<int,int> parent;
        parent[0] = -1;
        s.push(0);
        while(!s.empty()){
            int u = s.top();
            s.pop();
            visited.insert(u);
            for(auto v : G[u]){

                if(visited.count(v) > 0){
                    if(v == parent.at(u)){
                        continue;
                    }                    
                    return false;
                }
                parent[v] = u;
                s.push(v);
            }
        }
        if(visited.size() != n){return false;}
        return true;
    }
};
```
