## 774. Minimize Max Distance to Gas Station
<pre>
On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length.

Now, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.

Return the smallest possible value of D.

Example:

Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9
Output: 0.500000
Note:

stations.length will be an integer in range [10, 2000].
stations[i] will be an integer in range [0, 10^8].
K will be an integer in range [1, 10^6].
Answers within 10^-6 of the true value will be accepted as correct.
</pre>

--------------------------------------------------------------------

## Solutions

### Solution1
```c++
/*

The idea is to find the largest interval and update number of stations that should be added to it
example:

A = [10,19,25,27,56,63,70,87,96,97]
K= 3

intervals =             [9, 6, 2, 29, 7, 7, 17, 9, 1];
added stations count =  [1, 1, 1,  1, 1, 1,  1, 1, 1];//assuming adding 0 stations to all intervals at begining

iteration1: 29/1 is largest, increase its added stations to 1 and k--:

intervals =             [9, 6, 2, 29, 7, 7, 17, 9, 1];
added stations count =  [1, 1, 1,  2, 1, 1,  1, 1, 1];

iteration2: 17/1 is largest, increase its added stations to 1 and k--:

intervals =             [9, 6, 2, 29, 7, 7, 17, 9, 1];
added stations count =  [1, 1, 1,  2, 1, 1,  2, 1, 1];

iteration3: 29/2 is largest, increase its added stations to 2 and k--:

intervals =             [9, 6, 2, 29, 7, 7, 17, 9, 1];
added stations count =  [1, 1, 1,  3, 1, 1,  2, 1, 1];

all K stations have been added, and the largest is

29/3 = 9.66667

T(n) = O(n + klgn), where n is # of existing stations, k is the stations to be added
*/

class Solution {
public:
    double minmaxGasDist(vector<int>& stations, int K) {
        priority_queue<pair<double, int>,vector<pair<double, int>>, mycomp> MaxHeap;
        
        int n = stations.size();
        
        for(int i = 1; i < n; i++){
            MaxHeap.push({stations[i] - stations[i-1], 1});
        }
        
        while(K--){
            auto u = MaxHeap.top();
            MaxHeap.pop();
            u.second++;
            MaxHeap.push(u);
        }
        return MaxHeap.top().first/MaxHeap.top().second;
    }
private:
    struct mycomp{
        bool operator()(pair<double,int>& a, pair<double, int>& b){
            return a.first/a.second < b.first/b.second;
        }  
    };
};

```
