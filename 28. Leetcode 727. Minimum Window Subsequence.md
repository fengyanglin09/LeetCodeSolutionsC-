## 727. Minimum Window Subsequence


Given strings S and T, find the minimum (contiguous) substring W of S, so that T is a subsequence of W.

If there is no such window in S that covers all characters in T, return the empty string "". 
If there are multiple such minimum-length windows, return the one with the left-most starting index.

<pre>
Example 1:
Input: 
S = "abcdebdde", T = "bde"
Output: "bcde"
Explanation: 
"bcde" is the answer because it occurs before "bdde" which has the same length.
"deb" is not a smaller window because the elements of T in the window must occur in order.
 

Note:

All the strings in the input will only contain lowercase letters.
The length of S will be in the range [1, 20000].
The length of T will be in the range [1, 100].
</pre>
--------------------------------------------------------------------------
### Solutions

#### Method3: DP-2
```c++
/*
Method3 DP-variation2

from Method2, we had memory limit exceeded, bc we were storing substring directly.

In this DP-variation, we will store the starting index of each substring instead.

The dp formula is similar to method2:

dp[i][j] = dp[i-1][j-1], if S[i] == T[j]
dp[i][j] = dp[i-1][j], if S[i] != T[j]

special cases:
dp[0][0] = 0, if S[0] == T[0]
dp[0][0] = -1, if S[0] != T[0]
dp[0][j] = -1, for j > 0
dp[i][0] = i, if S[i] = T[0], i > 0
dp[i][0] = dp[i-1][0], if S[i] != T[0], i >0

example: let S = "gogzj", T = "ggj", then the dp table:
        g       g       j
g       0       -1      -1
o       0       -1      -1
g       2       0       -1
z       2       0       -1
j       2       0       0

T(n) = O(m*n)
S(n) = O(m*n)
*/
class Solution {
public:
    string minWindow(string S, string T) {
        int m = S.size();
        int n = T.size();
        vector<vector<int>>dp(m,vector<int>(n,-1));
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                //special cases:
                if(i == 0 && j == 0){
                    if(S[0] == T[0]){
                        dp[0][0] = 0;
                    }
                    continue;
                }
                if(i == 0 && j > i){
                    continue;
                }
                if(j == 0 && i > j){
                    if(S[i] == T[0]){
                        dp[i][j] = i;
                    }else{
                        dp[i][j] = dp[i-1][j];
                    }
                    continue;
                }
                //general cases:
                if(S[i] == T[j]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        string res = "";
        for(int i = 0; i < m; i++){
            if(dp[i][n-1] != -1){
                int start = dp[i][n-1];
                string sub = S.substr(start, i-start+1);
                if(res == ""){
                    res = sub;
                }
                else if(res.size() > sub.size()){
                    res = sub;
                }
            }
        }
        return res;
    }
};
```
------------------------------------------------------------------------
#### Method2: DP
```c++
/*
method2: DP, Memory Limi Exceeded, 51/59 test cases passed

Analysis:

let dp[i][j] be the mininum length substring ending with S[i] that may contain T[0,...,j], then

equation1: dp[i][j] = dp[i-1][j-1] + S[i], if dp[i-1][j-1] != "" && S[i] == S[j]; or
equation2: dp[i][j] = dp[i-1][j], if S[i] != S[j]

Note: the important thing is that dp[i][j] MIGHT be the substring met its definition above, 
there are situations the substring for dp[i][j] may not met the condition for the defintion.

special cases:
dp[0][0] = S[0], if S[0] == T[0]
dp[0][0] = "", if S[0] != T[0]
dp[0][j] = "", if j > 0
dp[i][0] = S[i], if S[i] == T[0]
dp[i][0] = "", if dp[i-1][0] == "" && S[i] != T[0]
dp[i][0] = dp[i-1][0] + S[i], if dp[i-1][0] != ""

Example:
let S = "abcdebdde", T="bde", then we have the following dp table:

            b               d               e
a          ""              ""              ""
b          b               ""              ""
c          bc              ""              ""
d          bcd             bcd             ""
e          bcde            bcd             bcde
b          b               ""              ""
d          bd              bd              ""
d          bdd             bdd             ""
e          bdde            bdd             bdde

from the dp table above, there are two possible answers: bcde, bdde
----------------------------------------------

However, the above dp will not work, consider the following example:
let S = "gogzj", T = "ggj", then the dp table (based on the dp above) would be:
        g       g       j
g       g       ""      ""
o       go      ""      ""
g       g       gog     ""
z       gz      gog     ""
j       gzj     gog     gogj

The string formed would be "gogj", clearly not the answer we were looking for.
The reason it did not work was because "gogj" at the lower right corner was 
formed from left upper diagnal "gog" + 'j', which should haven been "gog" + "zj".
'z' was skipped, bc, by definition, gog was the minimum length substring of S[0,...,3]
that maight contain T[0,...,1].

In short, the above dp did not enforce the constraint that the substring of S[0,...,3] must end with S[3]

therefore, the dp needs to be modified:

equation1: dp[i][j] = dp[i-1][j-1] + S[i], if dp[i-1][j-1] != "" && S[i] == S[j]; or
equation2: dp[i][j] = dp[i-1][j] + S[i], if S[i] != S[j]

special cases:
dp[0][j] = S[0],
dp[i][0] = S[i], if S[i] == T[0]
dp[i][0] = "", if dp[i-1][0] == "" && S[i] != T[0]
dp[i][0] = dp[i-1][0] + S[i], if dp[i-1][0] != ""


then the dp table fo the previous example will become:

        g       g       j
g       g       g       g
o       go      go      go
g       g       gog     gog
z       gz      gogz    gogz
j       gzj     gogzj   gogzj

T(n) = O(m*n)
S(n) = O(m*n*m)
*/
class Solution {
public:
    string minWindow(string S, string T) {
        int m = S.size();
        int n = T.size();
        vector<vector<string>> dp(m, vector<string>(n,""));

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                //special cases:
               
                if(i == 0){
                    dp[i][j] = S[0];
                    continue;
                }
                if(j == 0 && i > j){
                    if(S[i] == T[0]){
                        dp[i][j] = S[i];
                    }
                    else if(dp[i-1][j] != ""){
                        dp[i][j] = dp[i-1][j] + S[i];
                    }
                    continue;
                }
                
                ///general cases
                if (dp[i-1][j-1] != "" && S[i] == T[j]){
                    dp[i][j] = dp[i-1][j-1] + S[i];
                }else{
                    dp[i][j] = dp[i-1][j] + S[i];
                }
                
            }
        }
        
        
        ///get the result:
        string res = "";
        for(int i = 0; i < m; i++){
            if(contain(dp[i][n-1], T)){
                if(res == ""){
                    res = dp[i][n-1];
                }
                else if(res.size() > dp[i][n-1].size()){
                    res = dp[i][n-1];
                }
            }
        }

        return res;
    }
private:
    //determine if a constains all chars from b
    bool contain(string a, string b){
        int index = 0;
        for(int i = 0; i < a.size(); i++){
            if(a[i] == b[index]){
                index++;
                if(index >= b.size()){
                    return true;
                }
            }
        }
        return false;
    }
};
```
----------------------------------------------------------------------------------------------
#### Method1: Brute Force
```c++
/*
Method1: Brute Force, TLE, 51/59 test cases passed

T(n) = O(|S|^S), This the algorithm may search entire S everytime for seaching letters in T 
*/
class Solution {
public:
    string minWindow(string S, string T) {
        string res = "";
        for(int i = 0; i < S.size(); i++){
            if(S[i] == T[0]){
                int index = 0;
                string each = "";
                for(int j = i; j < S.size(); j++){
                    each+=S[j];
                    if(S[j] == T[index]){
                        index++;
                    }
                    if(index >= T.size()){
                        if(res.empty()){
                            res = each;
                        }
                        else if(res.size() > each.size()){
                            res = each;
                        }
                        break;
                    }
                }
            }
        }
        return res;
    }
};
```
